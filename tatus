warning: in the working copy of 'Metrics_models.py', CRLF will be replaced by LF the next time Git touches it
[1mdiff --git a/Adjust_masks_final.py b/Adjust_masks_final.py[m
[1mdeleted file mode 100644[m
[1mindex 738fe41..0000000[m
[1m--- a/Adjust_masks_final.py[m
[1m+++ /dev/null[m
[36m@@ -1,713 +0,0 @@[m
[31m-#!/usr/bin/env python3[m
[31m-# -*- coding: utf-8 -*-[m
[31m-[m
[31m-import json[m
[31m-import math[m
[31m-import numpy as np[m
[31m-import gzip[m
[31m-import openslide[m
[31m-import matplotlib.pyplot as plt[m
[31m-[m
[31m-from tqdm import tqdm[m
[31m-import scipy.ndimage as ndi[m
[31m-[m
[31m-from shapely.geometry import shape, mapping, Polygon, MultiPolygon[m
[31m-from shapely.ops import unary_union[m
[31m-from shapely.validation import make_valid[m
[31m-[m
[31m-from skimage.color import rgb2lab[m
[31m-from skimage.draw import polygon as rrcc_polygon[m
[31m-from skimage.measure import find_contours, label as sk_label[m
[31m-from skimage.morphology import remove_small_objects, remove_small_holes, binary_closing, reconstruction, disk[m
[31m-from scipy.ndimage import binary_fill_holes, binary_propagation, distance_transform_edt[m
[31m-[m
[31m-[m
[31m-# -----------------------------[m
[31m-# USER SETTINGS[m
[31m-# -----------------------------[m
[31m-SLIDE_TIFF = r"E:\Digital_Pathology\Project\molar_data\tif_slides\DP00002001.tif"[m
[31m-IN_GEOJSON = r"E:\Digital_Pathology\Project\Aron_to_share\Annotations\Adjusted_annotations\DP00002001.geojson.gz"[m
[31m-[m
[31m-# Output split:[m
[31m-OUT_GEOJSON_ADJUSTED = r"E:\Digital_Pathology\Project\Aron_to_share\Annotations\Adjusted_annotations\adjustedagain\DP00002001_adjusted.geojson"[m
[31m-OUT_GEOJSON_FAILED   = r"E:\Digital_Pathology\Project\Aron_to_share\Annotations\Adjusted_annotations\adjustedagain\DP00002001_failed.geojson"[m
[31m-[m
[31m-# ROI / geometry handling[m
[31m-PAD_PX = 64[m
[31m-MIN_OBJ_AREA = 0[m
[31m-MIN_HOLE_AREA = 2000[m
[31m-SMOOTH_RADIUS = 6[m
[31m-SMOOTH_BUF = 2[m
[31m-SIMPLIFY_TOL = 1.5[m
[31m-[m
[31m-# --- Background detection in LAB ---[m
[31m-BG_L_MIN = 97.0[m
[31m-BG_CHROMA_MAX = 10.0[m
[31m-[m
[31m-# --- OD barrier settings ---[m
[31m-USE_OD_BARRIER = True[m
[31m-OD_Q_EDGE = 0.40[m
[31m-OD_USE_BOUNDARY_BAND = True[m
[31m-OD_BAND_PX = 25[m
[31m-OD_SMOOTH_BARRIER_R = 1[m
[31m-OD_SMOOTH_BG_EDGE_R = 0[m
[31m-[m
[31m-# --- Bridge/thickness filters ---[m
[31m-BRIDGE_R = 0[m
[31m-THICK_MIN = 0[m
[31m-[m
[31m-# --- Repair ---[m
[31m-R_CLOSE = 0[m
[31m-[m
[31m-# --- PASS/FAIL safeguards ---[m
[31m-MIN_KEEP_RATIO = 0.50[m
[31m-SMALL_ORIG_PX = 100_000[m
[31m-MAX_REMOVE_SMALL = 20_000[m
[31m-[m
[31m-[m
[31m-# -----------------------------[m
[31m-# SciPy-safe structuring element[m
[31m-# -----------------------------[m
[31m-def se_disk(r: int):[m
[31m-    r = int(r)[m
[31m-    if r <= 0:[m
[31m-        return np.ones((1, 1), dtype=bool)[m
[31m-    return disk(r).astype(bool)[m
[31m-[m
[31m-[m
[31m-# -----------------------------[m
[31m-# HELPERS[m
[31m-# -----------------------------[m
[31m-def geom_to_xy_bounds_px(geom):[m
[31m-    minx, miny, maxx, maxy = geom.bounds[m
[31m-    return int(math.floor(minx)), int(math.floor(miny)), int(math.ceil(maxx)), int(math.ceil(maxy))[m
[31m-[m
[31m-[m
[31m-def clamp_roi(x, y, w, h, W, H):[m
[31m-    x = max(0, x); y = max(0, y)[m
[31m-    w = min(w, W - x); h = min(h, H - y)[m
[31m-    if w <= 2 or h <= 2:[m
[31m-        return None[m
[31m-    return x, y, w, h[m
[31m-[m
[31m-[m
[31m-def rasterize_geom_to_mask(geom, x0, y0, wL, hL, ds):[m
[31m-    """[m
[31m-    Rasterize a level-0 shapely geometry into a bool mask in ROI coordinates[m
[31m-    at pyramid level with downsample factor ds.[m
[31m-[m
[31m-    Inputs:[m
[31m-      geom : shapely Polygon/MultiPolygon in level-0 coords[m
[31m-      x0,y0: ROI top-left in level-0 coords (same as read_region location)[m
[31m-      wL,hL: ROI width/height in LEVEL pixels (size passed to read_region at that level)[m
[31m-      ds   : float downsample for that level (slide.level_downsamples[level])[m
[31m-[m
[31m-    Output:[m
[31m-      mask : (hL, wL) bool[m
[31m-    """[m
[31m-    mask = np.zeros((int(hL), int(wL)), dtype=bool)[m
[31m-    ds = float(ds)[m
[31m-[m
[31m-    def to_roi_level_xy(coords_xy):[m
[31m-        # coords_xy: Nx2 in level-0 coords -> ROI local in level pixels[m
[31m-        arr = np.asarray(coords_xy, dtype=np.float32)[m
[31m-        xs = (arr[:, 0] - x0) / ds[m
[31m-        ys = (arr[:, 1] - y0) / ds[m
[31m-        return xs, ys[m
[31m-[m
[31m-    def burn_poly(poly: Polygon):[m
[31m-        if poly.is_empty:[m
[31m-            return[m
[31m-[m
[31m-        # exterior[m
[31m-        xs, ys = to_roi_level_xy(poly.exterior.coords)[m
[31m-        rr, cc = rrcc_polygon(ys, xs, shape=mask.shape)[m
[31m-        mask[rr, cc] = True[m
[31m-[m
[31m-        # holes[m
[31m-        for hole in poly.interiors:[m
[31m-            xh, yh = to_roi_level_xy(hole.coords)[m
[31m-            rrh, cch = rrcc_polygon(yh, xh, shape=mask.shape)[m
[31m-            mask[rrh, cch] = False[m
[31m-[m
[31m-    if isinstance(geom, Polygon):[m
[31m-        burn_poly(geom)[m
[31m-[m
[31m-    elif isinstance(geom, MultiPolygon):[m
[31m-        for p in geom.geoms:[m
[31m-            burn_poly(p)[m
[31m-[m
[31m-    else:[m
[31m-        # try to fix invalid/other geom types[m
[31m-        g2 = geom.buffer(0)[m
[31m-        if isinstance(g2, Polygon):[m
[31m-            burn_poly(g2)[m
[31m-        elif isinstance(g2, MultiPolygon):[m
[31m-            for p in g2.geoms:[m
[31m-                burn_poly(p)[m
[31m-[m
[31m-    return mask[m
[31m-[m
[31m-[m
[31m-[m
[31m-def background_mask_white(rgb_u8, Lmin, cmax):[m
[31m-    rgb = rgb_u8.astype(np.float32) / 255.0[m
[31m-    lab = rgb2lab(rgb)[m
[31m-    L = lab[..., 0][m
[31m-    a = lab[..., 1][m
[31m-    b = lab[..., 2][m
[31m-    chroma = np.sqrt(a*a + b*b)[m
[31m-    return (L >= float(Lmin)) & (chroma <= float(cmax))[m
[31m-[m
[31m-[m
[31m-def bg_touching_annotation_boundary(bg, ann_mask):[m
[31m-    ann_er = ndi.binary_erosion(ann_mask, structure=np.ones((3, 3), np.uint8))[m
[31m-    ann_boundary = ann_mask & (~ann_er)[m
[31m-[m
[31m-    allowed = bg & ann_mask[m
[31m-    seeds = ann_boundary & allowed[m
[31m-    return binary_propagation(seeds, mask=allowed)[m
[31m-[m
[31m-[m
[31m-def bg_touching_annotation_boundary_odbarrier([m
[31m-    rgb_u8: np.ndarray,[m
[31m-    bg: np.ndarray,[m
[31m-    ann_mask: np.ndarray,[m
[31m-    q_edge: float = 0.90,[m
[31m-    use_boundary_band: bool = True,[m
[31m-    band_px: int = 25,[m
[31m-    smooth_barrier_r: int = 0,[m
[31m-    smooth_bg_edge_r: int = 0,[m
[31m-    close_barrier: bool = True,[m
[31m-):[m
[31m-    # annotation boundary seeds[m
[31m-    ann_er = ndi.binary_erosion(ann_mask, structure=np.ones((3, 3), np.uint8))[m
[31m-    ann_boundary = ann_mask & (~ann_er)[m
[31m-[m
[31m-    # OD sum[m
[31m-    I = (rgb_u8.astype(np.float32) + 1.0) / 255.0[m
[31m-    od = -np.log(I)[m
[31m-    od_sum = od[..., 0] + od[..., 1] + od[..., 2][m
[31m-[m
[31m-    # grad magnitude on OD sum[m
[31m-    gx = ndi.sobel(od_sum, axis=1)[m
[31m-    gy = ndi.sobel(od_sum, axis=0)[m
[31m-    grad = np.hypot(gx, gy)[m
[31m-[m
[31m-    # threshold estimate region[m
[31m-    if use_boundary_band:[m
[31m-        inner = ndi.binary_erosion([m
[31m-            ann_mask, structure=np.ones((3, 3), np.uint8),[m
[31m-            iterations=max(1, int(band_px))[m
[31m-        )[m
[31m-        band = ann_mask & (~inner)[m
[31m-        vals = grad[band][m
[31m-        if vals.size < 1000:[m
[31m-            vals = grad[ann_mask][m
[31m-    else:[m
[31m-        vals = grad[ann_mask][m
[31m-[m
[31m-    if vals.size == 0:[m
[31m-        edge_barrier = np.zeros_like(ann_mask, dtype=bool)[m
[31m-    else:[m
[31m-        T = float(np.quantile(vals, float(q_edge)))[m
[31m-        edge_barrier = (grad >= T) & ann_mask[m
[31m-[m
[31m-    # smooth barrier (SciPy-safe disks)[m
[31m-    if smooth_barrier_r and smooth_barrier_r > 0:[m
[31m-        se = se_disk(smooth_barrier_r)[m
[31m-[m
[31m-        if close_barrier:[m
[31m-            edge_barrier = ndi.binary_dilation(edge_barrier, structure=se)[m
[31m-            edge_barrier = ndi.binary_erosion(edge_barrier, structure=se)[m
[31m-[m
[31m-        edge_barrier = ndi.binary_erosion(edge_barrier, structure=se)[m
[31m-        edge_barrier = ndi.binary_dilation(edge_barrier, structure=se)[m
[31m-[m
[31m-        edge_barrier &= ann_mask[m
[31m-[m
[31m-    # flood fill of bg connected to boundary, blocked by barrier[m
[31m-    allowed = bg & ann_mask & (~edge_barrier)[m
[31m-    seeds = ann_boundary & allowed[m
[31m-    bg_edge = ndi.binary_propagation(seeds, mask=allowed)[m
[31m-[m
[31m-    # smooth bg_edge[m
[31m-    if smooth_bg_edge_r and smooth_bg_edge_r > 0:[m
[31m-        se = se_disk(smooth_bg_edge_r)[m
[31m-        bg_edge = ndi.binary_dilation(bg_edge, structure=se)[m
[31m-        bg_edge = ndi.binary_erosion(bg_edge, structure=se)[m
[31m-        bg_edge &= (bg & ann_mask)[m
[31m-[m
[31m-    return bg_edge, edge_barrier, grad[m
[31m-[m
[31m-[m
[31m-def mask_to_best_polygon_level(mask, x0, y0, ds):[m
[31m-    """[m
[31m-    Convert a boolean mask at pyramid level (downsample ds) into a Polygon in LEVEL-0 coords.[m
[31m-    x0,y0 are ROI origin in LEVEL-0 coords (same as read_region location).[m
[31m-    """[m
[31m-    if mask.sum() < MIN_OBJ_AREA:[m
[31m-        return None[m
[31m-[m
[31m-    contours = find_contours(mask.astype(np.uint8), 0.5)[m
[31m-    if not contours:[m
[31m-        return None[m
[31m-[m
[31m-    best_poly = None[m
[31m-    best_area = -1.0[m
[31m-    ds = float(ds)[m
[31m-[m
[31m-    for c in contours:[m
[31m-        # c: (row, col) in level pixels -> level-0 coords[m
[31m-        xs0 = x0 + c[:, 1] * ds[m
[31m-        ys0 = y0 + c[:, 0] * ds[m
[31m-        xy0 = np.column_stack([xs0, ys0])[m
[31m-[m
[31m-        if xy0.shape[0] < 3:[m
[31m-            continue[m
[31m-[m
[31m-        p = Polygon(xy0)[m
[31m-        if not p.is_valid:[m
[31m-            p = make_valid(p)[m
[31m-        if p.is_empty:[m
[31m-            continue[m
[31m-        if not isinstance(p, Polygon):[m
[31m-            try:[m
[31m-                p = unary_union(p)[m
[31m-            except Exception:[m
[31m-                continue[m
[31m-        if p.is_empty:[m
[31m-            continue[m
[31m-[m
[31m-        area = p.area[m
[31m-        if area > best_area:[m
[31m-            best_area = area[m
[31m-            best_poly = p[m
[31m-[m
[31m-    if best_poly is None or best_poly.is_empty:[m
[31m-        return None[m
[31m-[m
[31m-    # IMPORTANT: tolerances are in level-0 pixels now (good)[m
[31m-    if SIMPLIFY_TOL and SIMPLIFY_TOL > 0:[m
[31m-        best_poly = best_poly.simplify(SIMPLIFY_TOL, preserve_topology=True)[m
[31m-[m
[31m-    if not best_poly.is_valid:[m
[31m-        best_poly = make_valid(best_poly)[m
[31m-        if not isinstance(best_poly, Polygon):[m
[31m-            best_poly = unary_union(best_poly)[m
[31m-[m
[31m-    if best_poly.is_empty:[m
[31m-        return None[m
[31m-[m
[31m-    if SMOOTH_BUF and SMOOTH_BUF > 0:[m
[31m-        best_poly = best_poly.buffer(SMOOTH_BUF).buffer(-SMOOTH_BUF)[m
[31m-[m
[31m-    return best_poly[m
[31m-[m
[31m-[m
[31m-[m
[31m-def repair_mask_per_component(new_mask, ann_mask, r_close=0):[m
[31m-    if not new_mask.any():[m
[31m-        return new_mask[m
[31m-[m
[31m-    lab = sk_label(new_mask, connectivity=2)[m
[31m-    if lab.max() == 0:[m
[31m-        return new_mask[m
[31m-[m
[31m-    counts = np.bincount(lab.ravel())[m
[31m-    counts[0] = 0[m
[31m-    best_id = int(counts.argmax())[m
[31m-    comp = (lab == best_id)[m
[31m-[m
[31m-    if r_close and r_close > 0:[m
[31m-        se = se_disk(r_close)[m
[31m-        comp = ndi.binary_dilation(comp, structure=se)[m
[31m-        comp = ndi.binary_erosion(comp, structure=se)[m
[31m-[m
[31m-    comp = binary_fill_holes(comp)[m
[31m-    return comp & ann_mask[m
[31m-[m
[31m-[m
[31m-# -----------------------------[m
[31m-# CORE ADJUSTMENT[m
[31m-# -----------------------------[m
[31m-def adjust_annotation_geom(slide, geom):[m
[31m-    W, H = slide.dimensions[m
[31m-[m
[31m-    minx, miny, maxx, maxy = geom_to_xy_bounds_px(geom)[m
[31m-    x0 = minx - PAD_PX[m
[31m-    y0 = miny - PAD_PX[m
[31m-    w = (maxx - minx) + 2 * PAD_PX[m
[31m-    h = (maxy - miny) + 2 * PAD_PX[m
[31m-[m
[31m-    roi = clamp_roi(x0, y0, w, h, W, H)[m
[31m-    if roi is None:[m
[31m-        return geom, False[m
[31m-    x0, y0, w, h = roi[m
[31m-[m
[31m-    # --- choose pyramid level ---[m
[31m-    LVL = 3[m
[31m-    ds = float(slide.level_downsamples[LVL])[m
[31m-    [m
[31m-    # ROI size in level pixels[m
[31m-    wL = max(1, int(round(w / ds)))[m
[31m-    hL = max(1, int(round(h / ds)))[m
[31m-    [m
[31m-    # read ROI at level[m
[31m-    rgb = np.array(slide.read_region((x0, y0), LVL, (wL, hL)).convert("RGB"), dtype=np.uint8)[m
[31m-    [m
[31m-    # rasterize to the SAME level grid (IMPORTANT)[m
[31m-    ann_mask = rasterize_geom_to_mask(geom, x0, y0, wL, hL, ds)[m
[31m-    [m
[31m-    # bg on same grid[m
[31m-    bg = background_mask_white(rgb, BG_L_MIN, BG_CHROMA_MAX)[m
[31m-    [m
[31m-    # --- bg_edge ---[m
[31m-    if USE_OD_BARRIER:[m
[31m-        bg_edge, _, _ = bg_touching_annotation_boundary_odbarrier([m
[31m-            rgb, bg, ann_mask,[m
[31m-            q_edge=OD_Q_EDGE,[m
[31m-            use_boundary_band=OD_USE_BOUNDARY_BAND,[m
[31m-            band_px=OD_BAND_PX,[m
[31m-            smooth_barrier_r=OD_SMOOTH_BARRIER_R,[m
[31m-            smooth_bg_edge_r=OD_SMOOTH_BG_EDGE_R[m
[31m-        )[m
[31m-    else:[m
[31m-        bg_edge = bg_touching_annotation_boundary(bg, ann_mask)[m
[31m-[m
[31m-    # --- bridge prune ---[m
[31m-    if BRIDGE_R and BRIDGE_R > 0:[m
[31m-        se = se_disk(BRIDGE_R)[m
[31m-        seed = ndi.binary_erosion(bg_edge, structure=se)[m
[31m-        bg_edge = reconstruction([m
[31m-            seed.astype(np.uint8),[m
[31m-            bg_edge.astype(np.uint8),[m
[31m-            method="dilation"[m
[31m-        ).astype(bool)[m
[31m-[m
[31m-    # --- thickness-core filter ---[m
[31m-    if THICK_MIN and THICK_MIN > 0:[m
[31m-        dt = distance_transform_edt(bg_edge)[m
[31m-        core = dt >= int(THICK_MIN)[m
[31m-        se = se_disk(THICK_MIN)[m
[31m-        bg_edge = ndi.binary_dilation(core, structure=se) & bg_edge[m
[31m-[m
[31m-    # remove bg_edge from ann[m
[31m-    new_mask = ann_mask & (~bg_edge)[m
[31m-[m
[31m-    # repair (largest component)[m
[31m-    new_mask = repair_mask_per_component(new_mask, ann_mask, r_close=int(R_CLOSE) if R_CLOSE else 0)[m
[31m-[m
[31m-    # light cleanup[m
[31m-    if SMOOTH_RADIUS and SMOOTH_RADIUS > 0:[m
[31m-        new_mask = binary_closing(new_mask, footprint=disk(int(SMOOTH_RADIUS)))[m
[31m-        new_mask = remove_small_holes(new_mask, MIN_HOLE_AREA)[m
[31m-        new_mask = binary_fill_holes(new_mask)[m
[31m-[m
[31m-    new_mask = remove_small_objects(new_mask, MIN_OBJ_AREA)[m
[31m-    new_mask = remove_small_holes(new_mask, MIN_HOLE_AREA)[m
[31m-    new_mask = binary_fill_holes(new_mask)[m
[31m-[m
[31m-    # --- PASS/FAIL safeguards ---[m
[31m-    orig = int(ann_mask.sum())[m
[31m-    new  = int(new_mask.sum())[m
[31m-    removed = orig - new[m
[31m-[m
[31m-    if new < MIN_KEEP_RATIO * orig:[m
[31m-        return geom, False[m
[31m-[m
[31m-    if orig < SMALL_ORIG_PX and removed > MAX_REMOVE_SMALL:[m
[31m-        return geom, False[m
[31m-[m
[31m-    poly = mask_to_best_polygon_level(new_mask, x0, y0, ds)[m
[31m-    if poly is None:[m
[31m-        return geom, False[m
[31m-[m
[31m-    return poly, True[m
[31m-[m
[31m-[m
[31m-# -----------------------------[m
[31m-# DEBUG ONE FEATURE (full steps)[m
[31m-# -----------------------------[m
[31m-def debug_one_feature(idx, lvl=3):[m
[31m-    slide = openslide.OpenSlide(SLIDE_TIFF)[m
[31m-    ds = float(slide.level_downsamples[lvl])[m
[31m-    print("level:", lvl, "downsample:", ds)[m
[31m-[m
[31m-    # --- load feature ---[m
[31m-    with gzip.open(IN_GEOJSON, "rt", encoding="utf-8") as f:[m
[31m-        gj = json.load(f)[m
[31m-    features = gj["features"] if isinstance(gj, dict) and gj.get("type") == "FeatureCollection" else gj[m
[31m-    feat = features[idx][m
[31m-    geom_dict = feat["geometry"] if isinstance(feat, dict) and "geometry" in feat else feat[m
[31m-    geom = shape(geom_dict)[m
[31m-[m
[31m-    # --- ROI in level-0 coords ---[m
[31m-    minx, miny, maxx, maxy = geom.bounds[m
[31m-    x0 = int(math.floor(minx)) - PAD_PX[m
[31m-    y0 = int(math.floor(miny)) - PAD_PX[m
[31m-    w0 = int(math.ceil(maxx - minx)) + 2 * PAD_PX[m
[31m-    h0 = int(math.ceil(maxy - miny)) + 2 * PAD_PX[m
[31m-[m
[31m-    W, H = slide.dimensions[m
[31m-    x0 = max(0, x0); y0 = max(0, y0)[m
[31m-    w0 = min(w0, W - x0); h0 = min(h0, H - y0)[m
[31m-[m
[31m-    # --- ROI size in level pixels ---[m
[31m-    wL = max(1, int(round(w0 / ds)))[m
[31m-    hL = max(1, int(round(h0 / ds)))[m
[31m-[m
[31m-    # --- read ROI at level ---[m
[31m-    rgb = np.array(slide.read_region((x0, y0), lvl, (wL, hL)).convert("RGB"), dtype=np.uint8)[m
[31m-[m
[31m-    # --- rasterize annotation into SAME level grid ---[m
[31m-    ann_mask = rasterize_geom_to_mask(geom, x0, y0, wL, hL, ds)[m
[31m-[m
[31m-    if not ann_mask.any():[m
[31m-        print("EMPTY ann_mask at idx", idx)[m
[31m-        return[m
[31m-[m
[31m-    # --- background (LAB) ---[m
[31m-    bg = background_mask_white(rgb, BG_L_MIN, BG_CHROMA_MAX)[m
[31m-[m
[31m-    # --- bg_edge + OD barrier ---[m
[31m-    edge_barrier = np.zeros_like(ann_mask, dtype=bool)[m
[31m-    grad = None[m
[31m-[m
[31m-    if USE_OD_BARRIER:[m
[31m-        bg_edge, edge_barrier, grad = bg_touching_annotation_boundary_odbarrier([m
[31m-            rgb, bg, ann_mask,[m
[31m-            q_edge=OD_Q_EDGE,[m
[31m-            use_boundary_band=OD_USE_BOUNDARY_BAND,[m
[31m-            band_px=OD_BAND_PX,[m
[31m-            smooth_barrier_r=OD_SMOOTH_BARRIER_R,[m
[31m-            smooth_bg_edge_r=OD_SMOOTH_BG_EDGE_R,[m
[31m-            close_barrier=True[m
[31m-        )[m
[31m-    else:[m
[31m-        bg_edge = bg_touching_annotation_boundary(bg, ann_mask)[m
[31m-[m
[31m-    bg_edge_before_filters = bg_edge.copy()[m
[31m-[m
[31m-    # --- bridge prune ---[m
[31m-    if BRIDGE_R and BRIDGE_R > 0:[m
[31m-        se = se_disk(BRIDGE_R)[m
[31m-        seed = ndi.binary_erosion(bg_edge, structure=se)[m
[31m-        bg_edge = reconstruction(seed.astype(np.uint8), bg_edge.astype(np.uint8), method="dilation").astype(bool)[m
[31m-[m
[31m-    # --- thickness-core filter ---[m
[31m-    if THICK_MIN and THICK_MIN > 0:[m
[31m-        dt = distance_transform_edt(bg_edge)[m
[31m-        core = dt >= int(THICK_MIN)[m
[31m-        se = se_disk(THICK_MIN)[m
[31m-        bg_edge = ndi.binary_dilation(core, structure=se) & bg_edge[m
[31m-[m
[31m-    bg_edge_after_filters = bg_edge.copy()[m
[31m-[m
[31m-    # --- apply removal ---[m
[31m-    new_mask_raw = ann_mask & (~bg_edge)[m
[31m-[m
[31m-    # --- repair + cleanup ---[m
[31m-    new_mask = repair_mask_per_component(new_mask_raw, ann_mask, r_close=int(R_CLOSE) if R_CLOSE else 0)[m
[31m-[m
[31m-    if SMOOTH_RADIUS and SMOOTH_RADIUS > 0:[m
[31m-        new_mask = binary_closing(new_mask, footprint=se_disk(SMOOTH_RADIUS))[m
[31m-        new_mask = remove_small_holes(new_mask, MIN_HOLE_AREA)[m
[31m-        new_mask = binary_fill_holes(new_mask)[m
[31m-[m
[31m-    new_mask = remove_small_objects(new_mask, MIN_OBJ_AREA)[m
[31m-    new_mask = remove_small_holes(new_mask, MIN_HOLE_AREA)[m
[31m-    new_mask = binary_fill_holes(new_mask)[m
[31m-[m
[31m-    # --- pass/fail diagnostics ---[m
[31m-    orig = int(ann_mask.sum())[m
[31m-    new  = int(new_mask.sum())[m
[31m-    removed = orig - new[m
[31m-[m
[31m-    fail_reasons = [][m
[31m-    if new < MIN_KEEP_RATIO * orig:[m
[31m-        fail_reasons.append(f"MIN_KEEP_RATIO: new={new} < {MIN_KEEP_RATIO:.2f}*orig={orig}")[m
[31m-    if orig < SMALL_ORIG_PX and removed > MAX_REMOVE_SMALL:[m
[31m-        fail_reasons.append(f"MAX_REMOVE_SMALL: removed={removed} > {MAX_REMOVE_SMALL} (orig={orig})")[m
[31m-[m
[31m-    # polygon back in LEVEL-0 coords (IMPORTANT)[m
[31m-    poly = mask_to_best_polygon_level(new_mask, x0, y0, ds)[m
[31m-    if poly is None:[m
[31m-        fail_reasons.append("mask_to_best_polygon_level failed")[m
[31m-[m
[31m-    passed = (len(fail_reasons) == 0)[m
[31m-[m
[31m-    print("\n==============================")[m
[31m-    print("idx:", idx, "| level:", lvl, "| ds:", ds)[m
[31m-    print("ROI level0 w,h:", w0, h0, " | level w,h:", wL, hL)[m
[31m-    print("orig px:", orig, "new px:", new, "removed:", removed, "keep ratio:", round(new / max(1, orig), 4))[m
[31m-    print("passed:", passed)[m
[31m-    if not passed:[m
[31m-        print("FAIL REASONS:")[m
[31m-        for r in fail_reasons:[m
[31m-            print(" -", r)[m
[31m-[m
[31m-    # --- overlay boundaries on LEVEL image (for visualization only) ---[m
[31m-    overlay = rgb.copy()[m
[31m-    b_old = ann_mask & (~ndi.binary_erosion(ann_mask, structure=np.ones((3,3), np.uint8)))[m
[31m-    b_new = new_mask & (~ndi.binary_erosion(new_mask, structure=np.ones((3,3), np.uint8)))[m
[31m-    [m
[31m-    LINE_W_L0 = 10                       # desired thickness in level-0 pixels[m
[31m-    LINE_W_L  = max(1, int(round(LINE_W_L0 / ds)))  # convert to level pixels[m
[31m-    [m
[31m-    b_old = ndi.binary_dilation(b_old, structure=np.ones((3,3), np.uint8), iterations=LINE_W_L)[m
[31m-    b_new = ndi.binary_dilation(b_new, structure=np.ones((3,3), np.uint8), iterations=LINE_W_L)[m
[31m-    [m
[31m-    overlay[b_old] = [255, 0, 0][m
[31m-    overlay[b_new] = [0, 255, 0][m
[31m-    # --- plots ---[m
[31m-    fig, ax = plt.subplots(3, 4, figsize=(18, 12))[m
[31m-    ax = ax.ravel()[m
[31m-[m
[31m-    ax[0].imshow(rgb); ax[0].set_title(f"RGB (level {lvl})"); ax[0].axis("off")[m
[31m-    ax[1].imshow(ann_mask, cmap="gray"); ax[1].set_title("ann_mask (level grid)"); ax[1].axis("off")[m
[31m-    ax[2].imshow(bg, cmap="gray"); ax[2].set_title(f"bg LAB (L>={BG_L_MIN}, C<={BG_CHROMA_MAX})"); ax[2].axis("off")[m
[31m-    ax[3].imshow(edge_barrier, cmap="gray"); ax[3].set_title("edge_barrier (OD)"); ax[3].axis("off")[m
[31m-[m
[31m-    ax[4].imshow(bg_edge_before_filters, cmap="gray"); ax[4].set_title("bg_edge BEFORE filters"); ax[4].axis("off")[m
[31m-    ax[5].imshow(bg_edge_after_filters, cmap="gray"); ax[5].set_title("bg_edge AFTER filters"); ax[5].axis("off")[m
[31m-[m
[31m-    ax[6].imshow(new_mask_raw, cmap="gray"); ax[6].set_title("new_mask_raw"); ax[6].axis("off")[m
[31m-    ax[7].imshow(new_mask, cmap="gray"); ax[7].set_title("new_mask FINAL"); ax[7].axis("off")[m
[31m-[m
[31m-    if grad is not None:[m
[31m-        ax[8].imshow(grad, cmap="gray"); ax[8].set_title("OD grad magnitude"); ax[8].axis("off")[m
[31m-    else:[m
[31m-        ax[8].axis("off")[m
[31m-[m
[31m-    ax[9].imshow(overlay); ax[9].set_title(f"Overlay red=old green=new (passed={passed})"); ax[9].axis("off")[m
[31m-[m
[31m-    lab = rgb2lab(rgb.astype(np.float32)/255.0)[m
[31m-    L = lab[..., 0][m
[31m-    chroma = np.sqrt(lab[..., 1]**2 + lab[..., 2]**2)[m
[31m-    ax[10].hist(L[ann_mask].ravel(), bins=50); ax[10].set_title("L inside ann (level grid)")[m
[31m-    ax[11].hist(chroma[ann_mask].ravel(), bins=50); ax[11].set_title("Chroma inside ann (level grid)")[m
